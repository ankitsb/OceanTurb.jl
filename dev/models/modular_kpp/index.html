<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modular K-Profile Parameterization · OceanTurb.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>OceanTurb.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../basics/">Turbulence, fluxes, and physics</a></li><li><a class="toctext" href="../../numerics/">Numerical methods</a></li><li><span class="toctext">Turbulence models</span><ul><li><a class="toctext" href="../kpp/">The K-Profile-Parameterization (KPP)</a></li><li class="current"><a class="toctext" href>Modular K-Profile Parameterization</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Model-instantiaton-1">Model instantiaton</a></li><li class="toplevel"><a class="toctext" href="#Setting-boundary-conditions-1">Setting boundary conditions</a></li><li><a class="toctext" href="#Constant-and-standard-boundary-conditions-1">Constant and standard boundary conditions</a></li><li><a class="toctext" href="#More-complex-boundary-conditions-1">More complex boundary conditions</a></li><li class="toplevel"><a class="toctext" href="#Defining-forcing-functions-1">Defining forcing functions</a></li><li class="toplevel"><a class="toctext" href="#Sub-components-of-ModularKPP.Model-1">Sub-components of <code>ModularKPP.Model</code></a></li><li><a class="toctext" href="#Mixing-depth-models-1">Mixing depth models</a></li><li><a class="toctext" href="#Diffusivity-models-1">Diffusivity models</a></li><li><a class="toctext" href="#Non-local-flux-models-1">Non-local flux models</a></li></ul></li><li><a class="toctext" href="../tke_mass_flux/">An eddy-diffusivity mass-flux (EDMF) scheme with prognostic turbulent kinetic energy</a></li><li><a class="toctext" href="../pacanowskiphilander/">Pacanowski-Philander</a></li></ul></li><li><span class="toctext">DocStrings</span><ul><li><a class="toctext" href="../../man/types/">Private types</a></li><li><a class="toctext" href="../../man/functions/">Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Turbulence models</li><li><a href>Modular K-Profile Parameterization</a></li></ul><a class="edit-page" href="https://github.com/glwagner/OceanTurb.jl/blob/master/docs/src/models/modular_kpp.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Modular K-Profile Parameterization</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Modular-K-Profile-Parameterization-1" href="#Modular-K-Profile-Parameterization-1">Modular K-Profile Parameterization</a></h1><div>\[\newcommand{\c}         {\, ,}
\newcommand{\p}         {\, .}
\newcommand{\d}         {\partial}
\newcommand{\r}[1]      {\mathrm{#1}}
\newcommand{\b}[1]      {\boldsymbol{#1}}
\newcommand{\ee}        {\mathrm{e}}
\newcommand{\di}        {\, \mathrm{d}}
\newcommand{\ep}        {\epsilon}

\newcommand{\beq}       {\begin{equation}}
\newcommand{\eeq}       {\end{equation}}
\newcommand{\beqs}      {\begin{gather}}
\newcommand{\eeqs}      {\end{gather}}

% Non-dimensional numbers
\newcommand{\Ri}        {\mathrm{Ri}}
\newcommand{\Ek}        {\mathrm{Ek}}
\newcommand{\SL}        {\mathrm{SL}}
\newcommand{\K}         {\mathcal{E}}
\newcommand{\W}         {\mathcal{W}}

\newcommand{\btau}      {\b{\tau}} % wind stress vector

% Model functions and constants
\renewcommand{\F}[2]    {\Upsilon^{#1}_{#2}}
\renewcommand{\C}[2]    {C^{#1}_{#2}}

\newcommand{\uwind}     {u_\star}
\newcommand{\ubuoy}     {w_\star}

\newcommand{\NL}        {NL}\]</div><p>In the <code>ModularKPP</code> module, horizontally-averaged vertical turbulent fluxes are modeled with the combination of a local diffusive flux and a non-local non-diffusive flux:</p><div>\[\beq
\overline{w \phi} = - K_\Phi \d_z \Phi + \NL_\Phi \c
\eeq\]</div><p>where the depth dependence of the eddy diffusivity <span>$K_\Phi$</span> is </p><div>\[\beq
K_\Phi \propto h \, \W_\Phi \, \F{d}{}(d) \, ,
\eeq\]</div><p>where <span>$\W_\Phi$</span> is a turbulent velocity scale that in general depends on  <span>$\Phi$</span>, the quantity being diffused, <span>$d \equiv - z / h$</span> , and <span>$h$</span> is the &#39;mixing layer depth&#39;. Typically <span>$\F{d}{}$</span> is the cubic polynomial</p><div>\[\beq
\F{d}{}(d) = d ( 1 - d )^2 \, ,
\eeq\]</div><p>however, <code>ModularKPP</code> permits experimentation with different forms.</p><p>The formulation of diffusivity as the product of a magnitude with a with a shape or  &#39;profile&#39; function gives rise to the name. <span>$K$</span>-profile parameterization.</p><p>The non-local flux term <span>$\NL_\Phi$</span> models the effects of convective plumes.</p><p><span>$K$</span>-profile schemes with a non-local flux term thus have three basic components:</p><ol><li>A model for the mixing layer depth <span>$h$</span>, over which <span>$K_\Phi &gt; 0$</span>.</li><li>A model for the magnitude of the diffusivity, <span>$K$</span></li><li>A model or &quot;shape function&quot; that determines the dependence of <span>$K$</span> as a function of <span>$d=-z/h$</span>.</li><li>A model for the non-local flux, <span>$\NL_\Phi$</span>.</li></ol><h1><a class="nav-anchor" id="Model-instantiaton-1" href="#Model-instantiaton-1">Model instantiaton</a></h1><p>A <code>ModularKPP.Model</code> is instantiated in the default configuration by writing </p><pre><code class="language-julia">using OceanTurb
model = ModularKPP.Model()</code></pre><p>or,</p><pre><code class="language-julia">using OceanTurb

model = Model(grid = UniformGrid(N=10, L=1.0),
         constants = Constants(),
       diffusivity = LMDDiffusivity(),
      nonlocalflux = LMDCounterGradientFlux(),
       mixingdepth = LMDMixingDepth(),
          kprofile = StandardCubicPolynomial(),
           stepper = :BackwardEuler,
               bcs = ModelBoundaryConditions(eltype(grid)),
           forcing = Forcing())</code></pre><p>This builds a model on a <code>UniformGrid</code> with <code>N=10</code> grid points and <code>L=1.0</code> meters deep. The keyword arguments <code>diffusivity</code>, <code>nonlocalflux</code>, <code>mixingdepth</code>, and <code>kprofile</code> correspond  to a specific <span>$K$</span>-profile configuration proposed by <a href="https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/94rg01872">Large et al (1994)</a>:</p><ul><li><p><code>diffusivity = LMDDiffusivity()</code> determines the turbulent velocity scale <span>$W_\Phi$</span>    using the prescription proposed by LMD94</p></li><li><p><code>nonlocalflux = LMDCounterGradientFlux()</code> determines the nonlocal flux <span>$NL_\Phi$</span>   using the prescription proposed by LMD94</p></li><li><p><code>mixingdepth = LMDMixingDepth()</code> determines the mixing depth <span>$h$</span> using the bulk   Richardson number criterion proposed by LMD94</p></li><li><p><code>kprofile = StandardCubicPolynomial()</code> uses the cubic polynomial <span>$d(1-d)^2$</span> to set the primary    depth dependence of <span>$K_\Phi$</span>, as proposed by LMD94.</p></li></ul><p>More subcomponent choices and details about their consequences are described in  <a href="#Sub-components-of-ModularKPP.Model-1">Sub-components of <code>ModularKPP.Model</code></a>.</p><p>The keyword arguments <code>constants</code>, <code>stepper</code>, <code>bcs</code>, and <code>forcing</code> configure the model constants time stepper, boundary conditions, and forcing function. The only useful time-stepper at the moment is <code>:BackwardEuler</code>. The procedures for setting boundary conditions and defining forcing functions are described in  <a href="#Setting-boundary-conditions-1">Setting boundary conditions</a> and <a href="#Defining-forcing-functions-1">Defining forcing functions</a>.</p><p>The default set of constants is returned by <code>constants = Constants()</code>, or</p><pre><code class="language-julia">constants = Constants(
     α = 2.5e-4, # thermal expansion coefficient [C⁻¹]
     β = 8e-5,   # haline contraction coefficient [psu⁻¹]
    ρ₀ = 1035,   # reference density [kg m⁻³]
    cP = 3992,   # heat capacity `cP` [...]
     f = 0,      # Coriolis parameter `f` [s⁻¹]
     g = 9.81    # gravitational acceleration `g` [m² s⁻¹]
)</code></pre><h1><a class="nav-anchor" id="Setting-boundary-conditions-1" href="#Setting-boundary-conditions-1">Setting boundary conditions</a></h1><p>Two basic methods may be used to set boundary conditions. </p><h2><a class="nav-anchor" id="Constant-and-standard-boundary-conditions-1" href="#Constant-and-standard-boundary-conditions-1">Constant and standard boundary conditions</a></h2><p>For boundary conditions consisting of constant surface fluxes or constant bottom gradients, </p><pre><code class="language-julia">using OceanTurb

model = ModularKPP.Model()

model.bcs.U.top = BoundaryCondition(Flux, -1e-4)
model.bcs.T.top = BoundaryCondition(Flux, 1e-4)
model.bcs.T.bottom = BoundaryCondition(Gradient, model.constants.α * model.constants.g * 1e-5)</code></pre><p>will, for example, set the top boundary condition on temperature <code>T</code> to a positive flux of <span>$10^{-4} \, \mathrm{m K \, s^{-2}}$</span>, a bottom temperature gradient that corresponds to a bottom buoyancy gradient of <span>$N^2 = 10^{-5} \, \mathrm{s^{-2}}$</span>, and a top boundary condition on the horizontal velocity <code>U</code> to a negative flux.</p><p>In an oceanic scenario, a positive surface temperature flux of <span>$Q_\theta = 10^{-4}$</span>  is strongly destabilizing, corresponding to a heat flux of <span>$Q_h = \rho_0 c_P Q_\theta \approx 413 \, \mathrm{W \, m^{-2}}$</span>, or in ordinary oceanographic parlance a &#39;heating&#39; of <span>$-413 \, \mathrm{W \, m^{-2}}$</span>. (A positive surface flux extracts a quantity from the oceanic domain below; therefore  positive temperature flux acts to cool and destabilize at the ocean surface. This convention is standard –- an upward velocity leads to a positive flux, for example –- but is opposite the ordinary convention in oceanography.)</p><p>A negative flux of velocity accelerates surface fluid in the positive <span>$x$</span>-direction. A velocity flux, or kinematic stress of <span>$Q_u = -10^{-4}$</span> corresponds to a friction velocity of <span>$u_\star = | \boldsymbol{Q}_u |^{1/2} = 0.01 \, \mathrm{m \, s^{-1}}$</span> and a dynamic stress of <span>$\boldsymbol{\tau} = \rho_0 \boldsymbol{Q}_u \approx -10^{-1} \, \mathrm{N \, m^{-2}}$</span>.</p><h2><a class="nav-anchor" id="More-complex-boundary-conditions-1" href="#More-complex-boundary-conditions-1">More complex boundary conditions</a></h2><p>For non-standard or more complicated boundary conditions that are enforced, for example, by time-dependent or nonlinear functions, a variable&#39;s boundary condition must be generated prior to model instantiation and passed to the model constructor. To set a time-dependent surface flux of temperature for example, write</p><pre><code class="language-julia">using OceanTurb

# Functions-as-boundary-conditions take a single argument of type `ModularKPP.Model`.
fun_flux(model) = 1e-8 * cos(2π/day * model.clock.time)

# Wrap `fun_flux` in a `BoundaryCondition` and specify its application as a flux.
top_temperature_bc = BoundaryCondition(Flux, fun_flux)

# Instantiate boundary conditions for temperature with the flux function on top.
temperature_bcs = BoundaryConditions(top=top_temperature_bc)

# Instantiate a model with the indicated temperature boundary condition and default
# boundary conditions for all other variables.
model = Model(bcs = ModelBoundaryConditions(T=temperature_bcs))

# Constant boundary conditions of default type on other variables are still settable.
model.bcs.T.bottom = BoundaryCondition(Gradient, model.constants.α * model.constants.g * 1e-5)</code></pre><h1><a class="nav-anchor" id="Defining-forcing-functions-1" href="#Defining-forcing-functions-1">Defining forcing functions</a></h1><p>Forcing functions have the signature <code>forcing_func(model, i)</code>, where <code>model::ModularKPP.Model</code>, and <code>i</code> is the grid point at which the forcing is applied. For example, to apply a body force on <code>U</code>, write</p><pre><code class="language-julia">using OceanTurb

@inline body_force(model, i) = @inbounds -1e-1 * model.grid.zc[i] / model.grid.L

model = Model(forcing = Forcing(U=body_force))</code></pre><p>This instantiates a model with the specified body force applied to <span>$U$</span>, such that the <span>$U$</span> equation becomes</p><div>\[\beq
\partial_t U - f V = \partial_z \left ( K_U \partial_z U \right ) - 10^{-1} \frac{z}{L} \, .
\eeq\]</div><p>The annotations <code>@inline</code> tells the julia compiler to &quot;inline&quot; the function, which typically  increases performance, and the <code>@inbounds</code> annotation instructs the compiler to elide  bounds checking when indexing the range <code>model.grid.zc</code>, which also saves time provided that <code>body_force</code> is never called with <code>i</code> out of bounds.</p><h1><a class="nav-anchor" id="Sub-components-of-ModularKPP.Model-1" href="#Sub-components-of-ModularKPP.Model-1">Sub-components of <code>ModularKPP.Model</code></a></h1><h2><a class="nav-anchor" id="Mixing-depth-models-1" href="#Mixing-depth-models-1">Mixing depth models</a></h2><p>The mixing depth model is configured via the keyword argument <code>mixingdepth</code> in the <code>ModularKPP.Model</code> constructor.</p><h3><a class="nav-anchor" id="CVMix-mixing-depth-model-1" href="#CVMix-mixing-depth-model-1">CVMix mixing depth model</a></h3><p>The CVMix mixing depth model is instiated by writing</p><pre><code class="language-julia">mixingdepth = LMDMixingDepth()</code></pre><p>The <a href="https://github.com/CVMix/CVMix-description/raw/master/cvmix.pdf">CVMix</a> mixing depth model uses the &#39;bulk Richardson number&#39; criterion proposed by <a href="https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/94rg01872">Large et al (1994)</a>. This model is described in <a href="../kpp/#Mixing-depth-model-in-CVMix-KPP-1">Mixing depth model in CVMix KPP</a>.</p><h3><a class="nav-anchor" id="ROMS-mixing-depth-model-1" href="#ROMS-mixing-depth-model-1">ROMS mixing depth model</a></h3><p>The ROMS mixing depth model is instantiated by writing</p><pre><code class="language-julia">mixingdepth = ROMSMixingDepth()</code></pre><p>The mixing depth model used by the <a href="https://www.myroms.org">Regional Ocean Modeling System (ROMS)</a> is described in appendix B of <a href="https://journals.ametsoc.org/doi/full/10.1175/2009JPO4130.1">McWilliams et al (2009)</a>. The model introduces a &#39;mixing function&#39; <span>$\mathbb{M}$</span>, which is increased by shear and convection and decreased by stable stratification and rotation. <span>$\mathbb{M}$</span> is defined</p><div>\[\beq \label{stabilization}
\mathbb M(z) = \int_z^0 \F{\SL}{}(z&#39;) \left [
      \left ( \d_z \b{U} \right )^2 - \frac{\d_z B}{\C{\Ri}{}} - \C{\Ek}{} f^2
    \right ] \, \mathrm{d} z&#39;
    - \C{\K}{} \ubuoy^\dagger N^\dagger \c
\eeq\]</div><p>where</p><div>\[\beq
\ubuoy^\dagger(z) \equiv \max \left (0, -z F_b \right )^{1/3} \c
  \quad \mathrm{and} \quad
N^\dagger(z) \equiv \max \left (0, \d_z B \right )^{1/2} \p
\eeq\]</div><p>Typically, the mixing function <span>$\mathbb M(z)$</span> increases from 0 at <span>$z=0$</span> into the well-mixed region immediately below the surface due to <span>$\left ( \d_z \b{U} \right )^2$</span> and <span>$\ubuoy^\dagger N^\dagger$</span> during convection, and decreases to negative values in the stratified region below the mixing layer due to the stabilizing action of <span>$-\d_z B / \C{\Ri}{}$</span>. The boundary layer depth is defined as the first nonzero depth where <span>$\mathbb M(z) = 0$</span>.</p><p>Finally, the &#39;surface layer exclusion&#39; function,</p><div>\[\beq \label{exclusion}
\F{\SL}{} \equiv - \frac{z}{\C{\SL}{} h - z} \c
\eeq\]</div><p>acts to exclude the values of <span>$\left ( \d_z \b{U} \right )^2$</span> and <span>$\d_z B$</span> at the top of the boundary layer from influencing the diagnosed boundary layer depth.</p><p><a href="https://journals.ametsoc.org/doi/full/10.1175/2009JPO4130.1">McWilliams et al (2009)</a> suggest <span>$\C{\SL}{} = 0.1$</span>, <span>$\C{\K}{} = 5.07$</span>, <span>$\C{\Ri}{} = 0.3$</span>, and <span>$\C{\Ek}{} = 211$</span> for the free parameters in \eqref{stabilization}.</p><h2><a class="nav-anchor" id="Diffusivity-models-1" href="#Diffusivity-models-1">Diffusivity models</a></h2><h3><a class="nav-anchor" id="[Large-et-al-(1994)](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/94rg01872)-1" href="#[Large-et-al-(1994)](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/94rg01872)-1"><a href="https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/94rg01872">Large et al (1994)</a></a></h3><p>The diffusivity model proposed by  <a href="https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/94rg01872">Large et al (1994)</a> (LMD94) is instantiated by writing</p><pre><code class="language-julia">diffusivity = LMDDiffusivity()</code></pre><p>The LMD94 diffusivity model prescribes the turbulent velocity scale <span>$\W_\Phi(d)$</span> in the generic <span>$K$</span>-profile formulation,</p><div>\[\beq
K_\Phi \propto h \W^\text{LMD94}_\Phi(d) \F{d}{}(d) \, .
\eeq\]</div><p>The formulation of <span>$\W^\text{LMD94}_\Phi(d)$</span> is described in  <a href="../kpp/#K-Profile-model-in-CVMix-KPP-1"><span>$K$</span>-Profile model in CVMix KPP</a>.</p><p><code>ModularKPP.Model</code> permits a range of shape functions <span>$\F{d}{}(d)$</span> to be used with the LMD94 turbulent velocity scale <span>$\W_\Phi(d)$</span>.</p><h3><a class="nav-anchor" id="Holtslag-(1998)-1" href="#Holtslag-(1998)-1">Holtslag (1998)</a></h3><p>The diffusivity model proposed by Holtslag in 1998 and described in  <a href="https://journals.ametsoc.org/doi/full/10.1175/JAS3888.1">Siebesma et al (2007)</a> is instantiated by writing</p><pre><code class="language-julia">diffusivity = HoltslagDiffusivity()</code></pre><p>The Holtslag diffusivity uses the simple turublent velocity scale,</p><div>\[\beq
\W^\text{Holtslag} = \C{\tau}{} \ubuoy \left [ \left ( \frac{\uwind}{\ubuoy} \right )^3 
    + \C{\tau b}{} d \right ]^{1/3} \, .
\eeq\]</div><p><a href="https://journals.ametsoc.org/doi/full/10.1175/JAS3888.1">Siebesma et al (2007)</a>, which pair the turbulent velocity scale <span>$\W^\text{Holtslag}$</span> with a cubic shape function,  a diagnostic plume model and simple mixing depth model, suggest <span>$\C{\tau}{} = 0.4$</span> and <span>$\C{\tau b}{} = 15.6$</span>.</p><h2><a class="nav-anchor" id="Non-local-flux-models-1" href="#Non-local-flux-models-1">Non-local flux models</a></h2><h3><a class="nav-anchor" id="&#39;Countergradient-flux&#39;-model-1" href="#&#39;Countergradient-flux&#39;-model-1">&#39;Countergradient flux&#39; model</a></h3><p>The counter gradient flux model proposed by  <a href="https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/94rg01872">Large et al (1994)</a> is instantiated by writing</p><pre><code class="language-julia">nonlocalflux = LMDCounterGradientFlux()</code></pre><p>As described in  <a href="../kpp/#&#39;Countergradient&#39;-non-local-flux-model-in-CVMix-KPP-1">&#39;Countergradient&#39; non-local flux model in CVMix KPP</a>, the non-local countergradient flux is defined only for <span>$T$</span> and <span>$S$</span>, and is</p><div>\[\beq
NL_\phi = \C{\NL}{} F_\phi d (1 - d)^2 \c
\eeq\]</div><p>where <span>$d = -z/h$</span> is a non-dimensional depth coordinate and <span>$\C{\NL}{} = 6.33$</span>.</p><h3><a class="nav-anchor" id="Diagnostic-plume-model-1" href="#Diagnostic-plume-model-1">Diagnostic plume model</a></h3><p>The diagnostic plume model proposed by <a href="https://journals.ametsoc.org/doi/full/10.1175/JAS3888.1">Siebesma et al (2007)</a> is instantiated by writing</p><pre><code class="language-julia">nonlocalflux = DiagnosticPlumeModel()</code></pre><p>The diagnostic plume model described by <a href="https://journals.ametsoc.org/doi/full/10.1175/JAS3888.1">Siebesma et al (2007)</a> integrates equations that describe the quasi-equilibrium vertical momentum and  tracer budgets for plumes that plunge downwards from the ocean surface due to destabilizing buoyancy flux. </p><p>In the diagnostic plume model, the non-local flux of a tracer <span>$\Phi$</span> is parameterized as</p><div>\[\beq
    NL_\phi = \underbrace{\C{a}{} \breve W}_{\equiv M} \left ( \breve \Phi - \Phi \right ) \, ,
\eeq\]</div><p>where <span>$\C{a}{} = 0.1$</span> is the plume area fraction, <span>$\breve W$</span> is the plume vertical velocity, <span>$\breve \Phi$</span> is plume-averaged concentration of the  tracer <span>$\phi$</span>, and we have defined the mass flux <span>$M$</span>, which is negative for  down-travelling plumes. When using a plume model in <code>ModularKPP</code>, <span>$\Phi$</span> must be interpreted as the average concentration of <span>$\phi$</span> in the environment, excluding plume regions.</p><h4><a class="nav-anchor" id="Continuous-plume-equations-1" href="#Continuous-plume-equations-1">Continuous plume equations</a></h4><p>The diagnostic, steady-state plume-averaged temperature and salinity budgets boil down to</p><div>\[\begin{gather}
    \d_z \breve T = - \epsilon \left ( \breve T - T \right ) \, , \\
    \d_z \breve S = - \epsilon \left ( \breve S - S \right ) \, ,
\end{gather}\]</div><p>where <span>$\breve T$</span> and <span>$\breve S$</span> are the plume-averaged temperature and salinity,  and <span>$T$</span> and <span>$S$</span> are the environment-averaged temperature and salinity and  <span>$\epsilon(z, h)$</span> is the parameterized entrainment length, </p><div>\[\begin{align}
\epsilon(z) &amp;\equiv \frac{E}{\C{a}{} \breve W} \, , \\
    &amp;= -\C{\epsilon}{} 
        \left [ \frac{1}{\Delta c_N - z} + \frac{1}{\Delta c_N + \left ( z + h \right )} \right ] \, ,
\end{align}\]</div><p>where <span>$\C{\epsilon}{} = 0.4$</span>, <span>$\Delta c_N$</span> is the spacing between the boundary and the topmost cell interface, and <span>$h$</span> is the mixing depth determined via the chosen mixing depth model. We note that the definition of <span>$\epsilon$</span> in terms of the positive-definite  entrainment rate <span>$E&gt;0$</span>, area fraction <span>$\C{a}{}$</span>, and negative-definite downdraft plume velocity <span>$\breve W$</span> implies that <span>$\epsilon &lt; 0$</span>.</p><p>The budget for plume vertical momentum is</p><div>\[\beq
    \d_z \breve W^2 = \C{b}{w} \left ( \breve B - B \right ) - \C{\epsilon}{w} \epsilon \, \breve W^2
\eeq\]</div><p>where <span>$\breve B = \alpha \breve T - \beta \breve S$</span> is the plume-averaged buoyancy and  <span>$B = \alpha T - \beta S$</span> is the environment-averaged buoyancy, <span>$\C{b}{w} = 2.86$</span>,  and <span>$\C{\epsilon}{w} = 0.572$</span>.</p><h4><a class="nav-anchor" id="Surface-layer-plume-initialization-model-and-numerical-implementation-1" href="#Surface-layer-plume-initialization-model-and-numerical-implementation-1">Surface layer plume initialization model and numerical implementation</a></h4><p>The plume equations require boundary conditions at <span>$z=0$</span>, or an initialization model  at the topmost node in the interior of the domain.  Note that <span>$\breve T$</span> and <span>$\breve S$</span> are defined at cell centers, and  <span>$\breve W^2$</span> is defined at cell interfaces.</p><p>The plume-averaged tracer concentration in the topmost cell is parameterized in terms of the tracer flux across the top boundary, <span>$Q_\phi$</span>, with the formula</p><div>\[\beq
    \breve \Phi(z=z_N) = \Phi(z=z_N) - \C{\alpha}{} \frac{Q_\phi}{\sigma_w(z_N)} \, ,
\eeq\]</div><p>where <span>$\C{\alpha}{} = 1.0$</span>, and <span>$\sigma_w(z)$</span> is an empirical expression for the  vertical velocity standard deviation,</p><div>\[\beq
    \sigma_w = \left ( \C{\sigma \tau}{} \uwind^3 + \C{\sigma b}{} \ubuoy^3 d \right )^{1/3} \left ( 1 - d \right )^{1/2} \, ,
\eeq\]</div><p>with <span>$\C{\sigma \tau}{} = 2.2$</span> and <span>$\C{\sigma b}{} = 1.32$</span>.</p><p>The boundary condition on plume vertical momentum prescribes no penetration through the ocean surface,</p><div>\[\beq
    \breve W(z=0) = 0 \, .
\eeq\]</div><p>The advection terms in the diagnostic plume equations are discretized with a downwind scheme, which permits integration from the top at <span>$z=0$</span> downward. The plume temperature advection term, for example, is defined at cell centers and discretized with</p><div>\[\beq
\left ( \partial_z \breve T \right )_{i+1} = \frac{\breve T_{i+1} - \breve T_i}{\Delta c_{i+1}} \, .
\eeq\]</div><p>At the same time, the terms on the right side of the plume temperature conservation  equation are evaluated at cell center <code>i+1</code>, which leads to the integral</p><div>\[\beq
    \breve T_i = \breve T_{i+1} + \Delta c_{i+1} \epsilon \left ( z_{c, i+1} \right ) 
        \left ( \breve T_{i+1} - T_{i+1} \right ) \, ,
\eeq\]</div><p>that determines the plume temperature at cell center <code>i</code> with respect to plume temperature, environment temperature, and entrainment quantities evaluated at cell center <code>i+1</code>. The plume salinity conservaiton equation is discretized analogously.</p><p>The downwind discretization of the plume vertical momentum advection term is</p><div>\[\beq
\left ( \partial_z \breve W^2 \right )_{i+1} = \frac{ \breve W^2_{i+1} - \breve W^2_i }{\Delta f_{i+1}} \, .
\eeq\]</div><p>The plume vertical momentum is defined at cell interfaces. This means that discretizing the right side of the plume vertical momentum equation requires interpolating the buoyancy field from cell centers to cell interfaces. The plume vertical velocity equation is thus</p><div>\[\beq
    \breve W^2_i = \breve W^2_{i+1} - \Delta f_{i+1} \C{b}{w} \frac{1}{2} \left ( \breve B_i + \breve B_{i+1} - B_i - B_{i+1} \right ) + \Delta f_{i+1} \C{\epsilon}{w} \epsilon \left ( z_{f, i+1} \right ) \breve W^2_{i+1} \, .
\eeq\]</div><p>The plume integration is stopped at grid point <code>i</code> when <span>$\breve W^2_{i+1} &lt; 0$</span>.</p><p>In terms of the plume velocity variance <span>$\breve W^2$</span>, the mass flux is </p><div>\[\beq
M \equiv - \C{a}{} \sqrt{\breve W^2} \, ,
\eeq\]</div><p>which implies that the non-local flux <span>$NL_\phi$</span> is </p><div>\[\beq
NL_\phi = - \C{a}{} \sqrt{\breve W^2} \left ( \breve \Phi - \Phi \right ) \, .
\eeq\]</div><p>In <code>ModularKPP</code>, <span>$NL_\phi$</span> is treated explicitly.</p><footer><hr/><a class="previous" href="../kpp/"><span class="direction">Previous</span><span class="title">The K-Profile-Parameterization (KPP)</span></a><a class="next" href="../tke_mass_flux/"><span class="direction">Next</span><span class="title">An eddy-diffusivity mass-flux (EDMF) scheme with prognostic turbulent kinetic energy</span></a></footer></article></body></html>
